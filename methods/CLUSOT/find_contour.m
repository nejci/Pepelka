function [K]=find_contour(C,p,cn)
% [K]=find_contour(C,p,cn)
%
% find_contour computes the contour of a region in matrix C denoted
% by the value cn. Starting point for the search is point p, a
% point with its 4-neighbor not in the region. See
% 'Abramowski/Müller - Geometrisches Modellieren, S. 329 ff.'
% for details.
%
% Inputs:
% C - (matrix) for all points (x,y) in considered region C(x,y)=cn
% p - (vector) point with 4-neighbor not in region
% cn - (int) value which denotes region in C
% 
% Output:
% K - (matrix) sequence of contour points ending in p (n x 2 - matrix)
%
% $Id: find_contour.m 458 2005-03-20 11:40:32Z dome $
% D. Brugger, 18 March 2005
% algo/find_contour.m

if(nargin == 0)
  test_find_contour();
  return;
end

q=p; s=6; first=true; K=[]; pos=1;
while(~(sum(q == p) == 2) || first)
  found=false; idx=1;
  while(~found && idx <= 3)
    if(neighbor_in_region(s-1,q,C,cn))
      q=neighbor(s-1,q); s=mod(s-2,8); found=true;
    else 
      if(neighbor_in_region(s,q,C,cn))
        q=neighbor(s,q); found=true;
      else
        if(neighbor_in_region(s+1,q,C,cn))
          q=neighbor(s+1,q); found=true;
        else
          s=mod(s+2,8);
        end
      end
    end
    first=false; idx=idx+1;
  end
  K(pos,:)=q; pos=pos+1;
end

function b=neighbor_in_region(s,p,C,cn)
r=neighbor(s,p); [n,m]=size(C);
if(r(1) >= 1 && r(1) <= m && ...
   r(2) >= 1 && r(2) <= n && ...
   C(r(2),r(1)) == cn)
  b=true;
else
  b=false;
end

function r=neighbor(s,p)
s=mod(s,8); r=[NaN NaN];
switch s
 case 0
  r(1)=p(1)+1; r(2)=p(2);
 case 1
  r(1)=p(1)+1; r(2)=p(2)+1;
 case 2
  r(1)=p(1); r(2)=p(2)+1;
 case 3
  r(1)=p(1)-1; r(2)=p(2)+1;
 case 4
  r(1)=p(1)-1; r(2)=p(2);
 case 5
  r(1)=p(1)-1; r(2)=p(2)-1;
 case 6
  r(1)=p(1); r(2)=p(2)-1;
 case 7
  r(1)=p(1)+1; r(2)=p(2)-1;
 otherwise
end

function test_find_contour()
C=[0 0 1 1 1 0 1 1 0 0; ...
   0 1 1 1 1 1 1 1 1 1; ...
   0 0 1 1 1 0 0 1 0 0; ...
   0 0 0 0 1 1 1 0 0 0];
% Test case #1 - find outer contour
p=[2,2]; cn=1;
er=[2 2; ...
    3 3; ...
    4 3; ...
    5 4; ...
    6 4; ...
    7 4; ...
    8 3; ...
    9 2; ...
    10 2; ...
    9 2; ...
    8 1; ...
    7 1; ...
    6 2; ...
    5 1; ...
    4 1; ...
    3 1];
er=flipdim(er,1);
r=find_contour(C,p,cn)
check_equal(r,er,'r','er');
% Test case #2 - find inner contour
p=[8,3]; cn=1;
er=[7 2; ...
    6 2; ...
    5 3; ...
    6 4; ...
    7 4; ...
    8 3];
r=find_contour(C,p,cn)
check_equal(r,er,'r','er');
% Test case #3 - no inner contour
C=[0 0 1 1 0 0; ...
   0 1 1 1 1 1; ...
   1 1 1 0 0 1; ...
   1 1 0 0 0 1];
p=[2,2];
er=[3 1; ...
    4 1; ...
    5 2; ...
    6 2; ...
    6 3; ...
    6 4; ...
    6 3; ...
    5 2; ...
    4 2; ...
    3 3; ...
    2 4; ...
    1 4; ...
    1 3; ...
    2 2];
r=find_contour(C,p,cn)
check_equal(r,er,'r','er');
% Test case #4 - p at border of area
p=[1,3];
er=[2 2; ...
    3 1; ...
    4 1; ...
    5 2; ...
    6 2; ...
    6 3; ...
    6 4; ...
    6 3; ...
    5 2; ...
    4 2; ...
    3 3; ...
    2 4; ...
    1 4; ...
    1 3];
r=find_contour(C,p,cn)
check_equal(r,er,'r','er');
fprintf('test_find_contour succeded\n');
